<div class="docs-markdown"><p>The <code>a11y</code> package provides a number of tools to improve accessibility, described below.</p>
<h2>ListKeyManager</h2><p><code>ListKeyManager</code> manages the active option in a list of items based on keyboard interaction.
Intended to be used with components that correspond to a <code>role=&quot;menu&quot;</code> or <code>role=&quot;listbox&quot;</code> pattern.</p>

        <h3 id="basic-usage" class="docs-header-link">
          <span header-link="basic-usage"></span>
          Basic usage
        </h3>
      <p>Any component that uses a <code>ListKeyManager</code> will generally do three things:</p>
<ul>
<li>Create a <code>@ViewChildren</code> query for the options being managed.</li>
<li>Initialize the <code>ListKeyManager</code>, passing in the options.</li>
<li>Forward keyboard events from the managed component to the <code>ListKeyManager</code>.</li>
</ul>
<p>Each option should implement the <code>ListKeyManagerOption</code> interface:</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> ListKeyManagerOption {
  disabled?: <span class="hljs-built_in">boolean</span>;
  getLabel?(): <span class="hljs-built_in">string</span>;
}</code></pre>

        <h3 id="wrapping" class="docs-header-link">
          <span header-link="wrapping"></span>
          Wrapping
        </h3>
      <p>Navigation through options can be made to wrap via the <code>withWrap</code> method</p>
<pre><code class="language-ts"><span class="hljs-keyword">this</span>.keyManager = <span class="hljs-keyword">new</span> FocusKeyManager(...).withWrap();</code></pre>

        <h3 id="types-of-key-managers" class="docs-header-link">
          <span header-link="types-of-key-managers"></span>
          Types of key managers
        </h3>
      <p>There are two varieties of <code>ListKeyManager</code>, <code>FocusKeyManager</code> and <code>ActiveDescendantKeyManager</code>.</p>

        <h4 id="focuskeymanager" class="docs-header-link">
          <span header-link="focuskeymanager"></span>
          FocusKeyManager
        </h4>
      <p>Used when options will directly receive browser focus. Each item managed must implement the
<code>FocusableOption</code> interface:</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> FocusableOption <span class="hljs-keyword">extends</span> ListKeyManagerOption {
  focus(): <span class="hljs-built_in">void</span>;
}</code></pre>

        <h4 id="activedescendantkeymanager" class="docs-header-link">
          <span header-link="activedescendantkeymanager"></span>
          ActiveDescendantKeyManager
        </h4>
      <p>Used when options will be marked as active via <code>aria-activedescendant</code>.
Each item managed must implement the
<code>Highlightable</code> interface:</p>
<pre><code class="language-ts"><span class="hljs-keyword">interface</span> Highlightable <span class="hljs-keyword">extends</span> ListKeyManagerOption {
  setActiveStyles(): <span class="hljs-built_in">void</span>;
  setInactiveStyles(): <span class="hljs-built_in">void</span>;
}</code></pre>
<p>Each item must also have an ID bound to the listbox&#39;s or menu&#39;s <code>aria-activedescendant</code>.</p>
<h2>FocusTrap</h2><p>The <code>cdkTrapFocus</code> directive traps <kbd>Tab</kbd> key focus within an element. This is intended to
be used to create accessible experience for components like
<a href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal">modal dialogs</a>, where focus must be
constrained.</p>
<p>This directive is declared in <code>A11yModule</code>.</p>

        <h3 id="example" class="docs-header-link">
          <span header-link="example"></span>
          Example
        </h3>
      <pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"my-inner-dialog-content"</span> <span class="hljs-attr">cdkTrapFocus</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Tab and Shift + Tab will not leave this element. --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>This directive will not prevent focus from moving out of the trapped region due to mouse
interaction.</p>

        <h3 id="regions" class="docs-header-link">
          <span header-link="regions"></span>
          Regions
        </h3>
      <p>Regions can be declared explicitly with an initial focus element by using
the <code>cdkFocusRegionStart</code>, <code>cdkFocusRegionEnd</code> and <code>cdkFocusInitial</code> DOM attributes.
<code>cdkFocusInitial</code> specifies the element that will receive focus upon initialization of the region.
<code>cdkFocusRegionStart</code> and <code>cdkFocusRegionEnd</code> define the region within which focus will be
trapped. When using the tab key, focus will move through this region and wrap around on either end.</p>
<p>For example:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span> <span class="hljs-attr">routerLink</span> <span class="hljs-attr">cdkFocusRegionStart</span>&gt;</span>Focus region start<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span> <span class="hljs-attr">routerLink</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span> <span class="hljs-attr">routerLink</span> <span class="hljs-attr">cdkFocusInitial</span>&gt;</span>Initially focused<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">mat-list-item</span> <span class="hljs-attr">routerLink</span> <span class="hljs-attr">cdkFocusRegionEnd</span>&gt;</span>Focus region end<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>
<p><strong>Note:</strong> If you&#39;re using <code>cdkFocusInitial</code> together with the <code>CdkTrapFocus</code> directive, nothing
will happen unless you&#39;ve enabled the <code>cdkTrapFocusAutoCapture</code> option as well. This is due to
<code>CdkTrapFocus</code> not capturing focus on initialization by default.</p>
<h2>InteractivityChecker</h2><p><code>InteractivityChecker</code> is used to check the interactivity of an element, capturing disabled,
visible, tabbable, and focusable states for accessibility purposes. See the API docs for more
details.</p>
<h2>LiveAnnouncer</h2><p><code>LiveAnnouncer</code> is used to announce messages for screen-reader users using an <code>aria-live</code> region.
See <a href="https://www.w3.org/WAI/PF/aria-1.1/states_and_properties#aria-live">the W3C&#39;s WAI-ARIA</a>
for more information on aria-live regions.</p>

        <h3 id="example-1" class="docs-header-link">
          <span header-link="example-1"></span>
          Example
        </h3>
      <pre><code class="language-ts"><span class="hljs-meta">@Component</span>({...})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyComponent {

 <span class="hljs-keyword">constructor</span>(<span class="hljs-params">liveAnnouncer: LiveAnnouncer</span>) {
   liveAnnouncer.announce(<span class="hljs-string">"Hey Google"</span>);
 }
}</code></pre>
<h2>FocusMonitor</h2><p>The <code>FocusMonitor</code> is an injectable service that can be used to listen for changes in the focus
state of an element. It&#39;s more powerful than just listening for <code>focus</code> or <code>blur</code> events because it
tells you how the element was focused (via mouse, keyboard, touch, or programmatically). It also
allows listening for focus on descendant elements if desired.</p>
<p>To listen for focus changes on an element, use the <code>monitor</code> method which takes an element to
monitor and an optional boolean flag <code>checkChildren</code>. Passing true for <code>checkChildren</code> will tell the
<code>FocusMonitor</code> to consider the element focused if any of its descendants are focused. This option
defaults to <code>false</code> if not specified. The <code>monitor</code> method will return an Observable that emits the
<code>FocusOrigin</code> whenever the focus state changes. The <code>FocusOrigin</code> will be one of the following:</p>
<ul>
<li><code>&#39;mouse&#39;</code> indicates the element was focused with the mouse</li>
<li><code>&#39;keyboard&#39;</code> indicates the element was focused with the keyboard</li>
<li><code>&#39;touch&#39;</code> indicates the element was focused by touching on a touchscreen</li>
<li><code>&#39;program&#39;</code> indicates the element was focused programmatically</li>
<li><code>null</code> indicates the element was blurred</li>
</ul>
<p>In addition to emitting on the observable, the <code>FocusMonitor</code> will automatically apply CSS classes
to the element when focused. It will add <code>.cdk-focused</code> if the element is focused and will further
add <code>.cdk-${origin}-focused</code> (with <code>${origin}</code> being <code>mouse</code>, <code>keyboard</code>, <code>touch</code>, or <code>program</code>) to
indicate how the element was focused.</p>
<p>Note: currently the <code>FocusMonitor</code> emits on the observable <em>outside</em> of the Angular zone. Therefore
if you <code>markForCheck</code> in the subscription you must put yourself back in the Angular zone.</p>
<pre><code class="language-ts">focusMonitor.monitor(el).subscribe(<span class="hljs-function"><span class="hljs-params">origin</span> =&gt;</span> <span class="hljs-keyword">this</span>.ngZone.run(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-comment">/* ... */</span> ));</code></pre>
<p>Any element that is monitored by calling <code>monitor</code> should eventually be unmonitored by calling
<code>stopMonitoring</code> with the same element.</p>
<div material-docs-example="focus-monitor-overview"></div>

<p>It is possible to falsify the <code>FocusOrigin</code> when setting the focus programmatically by using the
<code>focusVia</code> method of <code>FocusMonitor</code>. This method accepts an element to focus and the <code>FocusOrigin</code>
to use. If the element being focused is currently being monitored by the <code>FocusMonitor</code> it will
report the <code>FocusOrigin</code> that was passed in. If the element is not currently being monitored it will
just be focused like normal.</p>
<div material-docs-example="focus-monitor-focus-via"></div>


        <h3 id="cdkmonitorelementfocus-and-cdkmonitorsubtreefocus" class="docs-header-link">
          <span header-link="cdkmonitorelementfocus-and-cdkmonitorsubtreefocus"></span>
          cdkMonitorElementFocus and cdkMonitorSubtreeFocus
        </h3>
      <p>For convenience, the CDK also provides two directives that allow for easily monitoring an element.
<code>cdkMonitorElementFocus</code> is the equivalent of calling <code>monitor</code> on the host element with
<code>checkChildren</code> set to <code>false</code>. <code>cdkMonitorSubtreeFocus</code> is the equivalent of calling <code>monitor</code> on
the host element with <code>checkChildren</code> set to <code>true</code>. Each of these directives has an <code>@Output()</code>
<code>cdkFocusChange</code> that will emit the new <code>FocusOrigin</code> whenever it changes.</p>
<div material-docs-example="focus-monitor-directives"></div>

<h2>Styling utilities</h2><p>The CDK <code>a11y</code> package comes with a set of CSS styles that can be used when building accessible
components. To take advantage of them, you have to include the styles in your global stylesheet.
If you&#39;re using Material together with the CDK, these styles have been included for you already.</p>
<pre><code class="language-scss">@<span class="hljs-keyword">import</span> <span class="hljs-string">'~@angular/cdk/text-field/text-field'</span>;

@<span class="hljs-keyword">include</span> cdk-a11y();</code></pre>

        <h3 id="hiding-elements-while-keeping-them-available-for-screen-readers" class="docs-header-link">
          <span header-link="hiding-elements-while-keeping-them-available-for-screen-readers"></span>
          Hiding elements, while keeping them available for screen readers
        </h3>
      <p>By default, screen readers and other assistive technology will skip elements that have
<code>display: none</code>, <code>visibility: hidden</code> etc. In some cases you may need to visually hide an element,
while keeping it available for assistive technology. You can do so using the <code>cdk-visually-hidden</code>
class:</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"custom-checkbox"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cdk-visually-hidden"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>

        <h3 id="targeting-high-contrast-users" class="docs-header-link">
          <span header-link="targeting-high-contrast-users"></span>
          Targeting high contrast users
        </h3>
      <p>The <code>a11y</code> package offers a mixin that allows you to target users that have the Windows high
contrast mode turned on. To target high contrast users, you can wrap your styles with the
<code>cdk-high-contrast</code> mixin. The mixin works by targeting a CSS class which is added to the <code>body</code>
by the CDK when high contrast mode is detected at runtime.</p>
<pre><code class="language-scss"><span class="hljs-selector-tag">button</span> {
  @<span class="hljs-keyword">include</span> cdk-high-contrast {
    <span class="hljs-attribute">outline</span>: solid <span class="hljs-number">1px</span>;
  }
}</code></pre>
</div>